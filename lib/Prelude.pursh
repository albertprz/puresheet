module Prelude


op <| = apply R0

op |> = applyFlipped L1

op || = or R2

op && = and R3

op == = eq L4

op != = notEq L4

op > = gt L4

op >= = gtOrEq L4

op < = lt L4

op >= = ltOrEq L4

op ++ = append R5

op +: = cons R6

op :+ = snoc L7

op + = add L8

op |+| = Array.add L8

op ||+|| = Matrix.add L8

op - = sub L9

op |-| = Array.sub L9

op ||-|| = Matrix.sub L9

op <<< = compose R9

op >>> = composeFlipped R9

op * = mult L10

op |*| = Array.mult L10

op ||*|| = Matrix.mult L10

op / = div L11

op |/| = Array.mult L11

op ||/|| = Matrix.mult L11

op % = mod L11


def id (x: A): A =
    x

def const (x: A): B -> A =
    y -> x

def apply (f: A -> B, x: A): B =
    f (x)

def compose (f: A -> B, g: B -> C): A -> C =
    x -> f (g (x))

def flip (f: A -> B -> C): B -> A -> C =
    (x, y) -> f (y, x)

def map (f: A -> B, xs: [A]): [B] =
    switch (xs) {
        | []            => []
        | [ x, xs @ ... ] => f (x) +: map (f, xs)
    }

def filter (f: A -> Boolean, xs: [A]): [A] =
    switch (xs) {
        | []                        => []
        | [ x, xs @ ... ] ? f(x)    => x +: filter (f, xs)
                        ? otherwise => filter (f, xs)
    }

def reduce (f: B -> A -> B, start: B, xs: [A]): B =
        switch (xs) {
        | []             => start
        | [ x, xs @ ... ] => f (x, reduce (f, start, xs))
    }

def fold (f: A -> A -> A, xs: [A]): A =
    switch (xs) {
        | []            => null
        | [ x, xs @ ... ] => reduce (f, x, xs)
    }

def zipWith (f: A -> B -> C, xs: [A], ys: [B]): [C] =
    cond {
        ? isEmpty (xs) || isEmpty (ys) => []
        ? otherwise =>
            f (head (xs), head (ys)) +: zipWith (f, tail (xs), tail (ys))
    }

def iterate (f: A -> A, start: A, n: Int): [A] =
    cond {
        ? n == 0     => [start]
        ? otherwise => start +: iterate (f, f (start), n - 1)
    }

def isEmpty (xs: [A]): Boolean =
    switch (xs) {
        | [] => true
        | "" => true
        | _  => false
    }

def isNotEmpty (xs: [A]): Boolean =
    not (isEmpty (xs))

def all (f: A -> Boolean, xs: [A]): Boolean =
    reduce (and, true, map (f, xs))

def any (f: A -> Boolean, xs: [A]): Boolean =
    reduce (or, false, map (f, xs))


def sum (xs: [Number]): Number  =
    reduce (add, 0, xs)

def product (xs: [Number]): Number =
    reduce (mult, 0, xs)

def average (xs: [Number]): Number =
    sum (xs) / 2
