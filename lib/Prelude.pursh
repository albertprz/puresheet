module Prelude

op <| = apply R0

op |> = applyFlipped L1

op || = or R2

op && = and R3

op == = eq L4

op != = notEq L4

op > = gt L4

op >= = gtOrEq L4

op < = lt L4

op >= = ltOrEq L4

op ++ = append R5

op +: = cons R6

op :+ = snoc L7

op + = add L8

op |+| = arrayAdd L8

op ||+|| = matrixAdd L8

op - = sub L9

op |-| = arraySub L9

op ||-|| = matrixSub L9

op <<< = compose R9

op >>> = composeFlipped R9

op * = mult L10

op |*| = arrayMult L10

op ||*|| = matrixMult L10

op / = div L11

op |/| = arrayMult L11

op ||/|| = matrixMult L11

op % = mod L11


def id (x: A): A =
    x

def const (x: A): B -> A =
    y -> x

def apply (f: A -> B, x: A): B =
    f (x)

def compose (f: A -> B, g: B -> C): A -> C =
    x -> f (g (x))

def flip (f: A -> B -> C): B -> A -> C =
    (x, y) -> f (y, x)

def map (f: A -> B, xs: [A]): [B] =
    switch (xs) {
        | []             => []
        | [ xs @ ... , x ] => map (f, xs) :+ f (x)
    }

def mapMatrix (f: A -> B, xss: [[A]]): [[B]] =
    map (map (f), xss)

def filter (f: A -> Boolean, xs: [A]): [A] =
    switch (xs) {
        | []                         => []
        | [ xs @ ... , x ] ? f(x)      => filter (f, xs) :+ x
                        ? otherwise => filter (f, xs)
    }

def filterMatrix (f: A -> Boolean, xss: [[A]]): [[A]] =
    map (filter (f), xss)

def reduce (f: B -> A -> B, start: B, xs: [A]): B =
    reduceRight (flip (f), start, reverse (xs)) where {
        | reduceRight (f, start, xs) = switch (xs) {
            | []             => start
            | [ xs @ ... , x ] => f (x, reduceRight (f, start, xs))
        }
    }

def reduceMatrix (f: B -> A -> B, start: B, xss: [A]): B =
    reduce (reduce (f), start, xss)

def reduceRecur (f: B -> A -> B, start: B, xs: [A] | [[A]]): B =
    switch (head (xss)) {
        | []     => reduceMatrix (f, start, xss)
        | [ ... ]  => reduceMatrix (f, start, xss)
        | _      => reduce (f, start, xss)
    }

def fold (f: A -> A -> A, xs: [A]): A =
    switch (xs) {
        | []            => null
        | [ x, xs @ ... ] => reduce (f, x, xs)
    }

def foldMatrix (f: A -> A -> A, xss: [[A]]): A =
    fold (fold (f))

def foldRecur (f: A -> A -> A, xs: [A] | [[A]]): A =
    switch (head (xss)) {
        | []     => foldMatrix (f, xss)
        | [ ... ]  => foldMatrix (f, xss)
        | _      => fold (f, xss)
    }

def zipWith (f: A -> B -> C, xs: [A], ys: [B]): [C] =
    cond {
        ? empty (xs) || empty (ys) => []
        ? otherwise =>
            zipWith(f, init (xs), init (ys)) :+ f (tail (xs), tail (ys))
    }

def zipMatrixWith (f: A -> B -> C, xss: [[A]], yss: [[B]]): [[C]] =
    zipWith (zipWith (f), xss, yss)

def iterate (f: A -> A, start: A, n: Int): [A] =
    reverse (go (f, start, n)) where {
        | go (f, start, n) = cond {
            ? n == 0     => start
            ? otherwise => go (f, f(start), n - 1) :+ start
        }
    }

def empty (xs: [A]): Boolean =
    length (xs) == 0

def nonEmpty (xs: [A]): Boolean =
    not (empty (xs))



def sum (xs: [Number] | [[Number]]): Number  =
    foldRecur (add, xs)

def product (xs: [Number] | [[Number]]): Number =
    foldRecur (mult, xs)

def average (xs: [Number] | [[Number]]): Number =
    sum (xs) / 2

def arrayAdd (xs: [Number], ys: [Number]): [Number] =
    zipWith (add, xs, ys)

def arraySub (xs: [Number], ys: [Number]): [Number] =
    zipWith (sub, xs, ys)

def arrayMult (xs: [Number], ys: [Number]): [Number] =
    zipWith (mult, xs, ys)

def arrayDiv (xs: [Number], ys: [Number]): [Number] =
    zipWith (div, xs, ys)

def matrixAdd (xss: [[Number]], ys: [[Number]]): [[Number]] =
    zipWithMatrix (add)

def matrixSub (xss: [[Number]], ys: [[Number]]): [[Number]] =
    zipWithMatrix (sub)

def matrixMult (xss: [[Number]], ys: [[Number]]): [[Number]] =
    zipWithMatrix (mult)

def matrixDiv (xss: [[Number]], ys: [[Number]]): [[Number]] =
    zipWithMatrix (div)
